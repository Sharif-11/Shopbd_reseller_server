// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "rhel-openssl-1.0.x", "linux-musl"]
  // previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // extensions = [vector]
}

model Otp {
  id             String    @id @default(cuid()) // Use cuid for unique id
  phoneNo        String    @unique
  isVerified     Boolean   @default(false)
  isBlocked      Boolean   @default(false)
  totalOTP       Int       @default(0)
  otp            String // Optional
  otpCreatedAt   DateTime // Optional, timestamp when OTP was created
  otpExpiresAt   DateTime // Optional, timestamp when OTP expires
  otpBlockUntil  DateTime? // Optional, timestamp until which the OTP is blocked
  failedAttempts Int       @default(0) // Count of failed attempts
  createdAt      DateTime  @default(now()) // Timestamp for creation
  updatedAt      DateTime  @updatedAt // Timestamp for updates

  @@index([phoneNo], name: "contactIndex")
  @@map("otp") // Optional: Custom table name in the database
}

// User Management Schema

// ======================
// ENUMS
// ======================

enum UserType {
  Seller
  Admin
  SuperAdmin // Changed from Super_Admin
}

enum PermissionType {
  USER_MANAGEMENT
  PRODUCT_MANAGEMENT
  ORDER_MANAGEMENT
  WITHDRAWAL_MANAGEMENT
  PAYMENT_MANAGEMENT
  WALLET_MANAGEMENT
  ROLE_PERMISSIONS
  ALL
}

enum ActionType {
  ALL
  CREATE
  READ
  UPDATE
  DELETE
  APPROVE
  REJECT
  BLOCK
}

enum BlockActionType {
  ORDER_REQUEST
  WITHDRAW_REQUEST
  PASSWORD_RESET
  PAYMENT_REQUEST
  WALLET_ADDITION
  ALL
}

enum PaymentStatus {
  PENDING
  COMPLETED
  CANCELLED
  REJECTED
  FAILED
}

enum PaymentType {
  ORDER_PAYMENT
  WITHDRAWAL_PAYMENT
  DUE_PAYMENT
}

enum SenderType {
  SELLER
  SYSTEM
  CUSTOMER
}

enum WithdrawStatus {
  PENDING
  COMPLETED
  REJECTED
  CANCELLED
}

enum OrderType {
  SELLER_ORDER
  CUSTOMER_ORDER
}

enum OrderStatus {
  UNPAID
  PAID
  CONFIRMED
  DELIVERED
  COMPLETED
  RETURNED
  REFUNDED
  FAILED
  CANCELLED
  REJECTED
}

enum OrderUser {
  SELLER
  CUSTOMER
  SYSTEM
}

enum PaymentMethod {
  WALLET
  BALANCE
}

// ======================
// MODELS
// ======================

model User {
  userId                     String    @id @default(cuid())
  phoneNo                    String    @unique
  name                       String
  password                   String
  passwordSendsAt            DateTime?
  totalPasswordResetRequests Int       @default(0)

  role UserType @default(Seller)

  zilla               String?
  upazilla            String?
  address             String?
  referralCode        String?    @unique
  referredBy          User?      @relation("UserReferredBy", fields: [referredByPhone], references: [phoneNo], onDelete: NoAction, onUpdate: Cascade)
  referredByPhone     String?
  referrals           User[]     @relation("UserReferredBy")
  email               String?    @unique
  isVerified          Boolean?   @default(false)
  balance             Decimal?   @default(0.0) @db.Decimal(15, 2)
  shopName            String?
  nomineePhone        String?
  facebookProfileLink String?
  createdAt           DateTime   @default(now())
  updatedAt           DateTime   @updatedAt
  version             Int        @default(1)
  userRoles           UserRole[]
  Wallet              Wallet[]

  @@index([phoneNo], name: "userIndex")
  @@map("users")
}

model Customer {
  customerId      String   @id @default(cuid())
  customerName    String
  customerPhoneNo String   @unique
  role            String   @default("Customer") // Constant string value
  sellerId        String
  sellerCode      String
  sellerName      String
  sellerPhone     String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([customerPhoneNo], name: "customerPhoneIndex")
  @@map("customers")
}

model Role {
  roleId          String           @id @default(cuid())
  roleName        String           @unique @default("Seller")
  roleDescription String?
  isDefault       Boolean          @default(false)
  permissions     RolePermission[]
  userRoles       UserRole[]
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@map("roles")
}

model RolePermission {
  rolePermissionId String         @id @default(cuid())
  roleId           String
  permission       PermissionType
  actions          ActionType[]
  role             Role           @relation(fields: [roleId], references: [roleId])

  @@unique([roleId, permission])
  @@map("role_permissions")
}

model UserRole {
  userRoleId String @id @default(cuid())
  userId     String
  roleId     String
  user       User   @relation(fields: [userId], references: [userId])
  role       Role   @relation(fields: [roleId], references: [roleId])

  @@unique([userId, roleId])
  @@map("user_roles")
}

model Block {
  blockId     String        @id @default(cuid())
  userName    String
  userPhoneNo String
  actions     BlockAction[] // One-to-many relationship with BlockAction
  isActive    Boolean       @default(true)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@index([userPhoneNo], name: "blockUserPhoneIndex")
  @@map("blocks")
}

model BlockAction {
  actionId   String          @id @default(cuid())
  block      Block           @relation(fields: [blockId], references: [blockId])
  blockId    String
  actionType BlockActionType
  reason     String?
  expiresAt  DateTime?
  createdAt  DateTime        @default(now())

  // Properly define the composite unique constraint
  @@unique([blockId, actionType])
  @@map("block_actions")
}

// ======================
// RELATIONSHIP DIAGRAM
// ======================

// User ↔ UserRole ↔ Role
// Role ↔ RolePermission
// User → User (self-referential for referrals)
// Block → User/Customer (via userPhoneNo)

// ======================
// WALLET MANAGEMENT
// ======================
model Wallet {
  walletId      Int        @id @default(autoincrement()) // Primary key, auto-incremented
  walletName    String // Name of the wallet
  walletPhoneNo String // Associated phone number
  walletType    WalletType @default(SELLER) // Type of wallet, defaulting to SELLER

  user   User?   @relation(fields: [userId], references: [userId])
  userId String?

  createdAt DateTime @default(now()) // Timestamp for creation
  updatedAt DateTime @updatedAt // Timestamp for updates

  @@unique([walletName, walletPhoneNo]) // Composite unique constraint
  @@map("wallets") // Optional: Custom table name in the database
}

model WalletOtp {
  id             String    @id @default(cuid()) // Use cuid for unique id
  phoneNo        String    @unique
  isVerified     Boolean   @default(false)
  isBlocked      Boolean   @default(false)
  totalOTP       Int       @default(0)
  otp            String // Optional
  otpCreatedAt   DateTime // Optional, timestamp when OTP was created
  otpExpiresAt   DateTime // Optional, timestamp when OTP expires
  otpBlockUntil  DateTime? // Optional, timestamp until which the OTP is blocked
  failedAttempts Int       @default(0) // Count of failed attempts
  createdAt      DateTime  @default(now()) // Timestamp for creation
  updatedAt      DateTime  @updatedAt // Timestamp for updates

  @@index([phoneNo], name: "walletOtpIndex") // Index for phoneNo
  @@map("wallet_otp") // Optional: Custom table name in the database
}

enum WalletType {
  SELLER
  SYSTEM
}

// ======================
// PRODUCT MANAGEMENT
// ======================

model Shop {
  shopId                Int            @id @default(autoincrement())
  shopName              String
  shopLocation          String
  shopIcon              String? // New optional field for shop icon
  deliveryChargeInside  Decimal        @db.Decimal(10, 2)
  deliveryChargeOutside Decimal        @db.Decimal(10, 2)
  shopDescription       String?
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
  isActive              Boolean        @default(true)
  Product               Product[]
  shopCategories        ShopCategory[]

  @@map("shops")
}

// All other models remain exactly the same as in your previous schema
model Category {
  categoryId     Int            @id @default(autoincrement())
  name           String
  categoryIcon   String?
  description    String?
  parentId       Int? // Reference to parent category
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  Product        Product[]
  shopCategories ShopCategory[]

  // Self-referential relationship for parent-child
  parentCategory Category?  @relation("CategoryHierarchy", fields: [parentId], references: [categoryId])
  subCategories  Category[] @relation("CategoryHierarchy")

  @@map("categories")
}

model ShopCategory {
  shopCategoryId Int      @id @default(autoincrement())
  shopId         Int
  categoryId     Int
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  shop     Shop     @relation(fields: [shopId], references: [shopId])
  category Category @relation(fields: [categoryId], references: [categoryId])

  @@unique([shopId, categoryId], name: "uniqueShopCategory")
  @@map("shop_categories")
}

model Product {
  productId         Int      @id @default(autoincrement())
  categoryId        Int
  shopId            Int
  name              String
  description       String
  published         Boolean  @default(false)
  videoUrl          String?
  basePrice         Decimal  @db.Decimal(15, 2)
  suggestedMaxPrice Decimal  @db.Decimal(15, 2)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  category       Category         @relation(fields: [categoryId], references: [categoryId])
  shop           Shop             @relation(fields: [shopId], references: [shopId])
  ProductImage   ProductImage[]
  ProductVariant ProductVariant[]

  @@map("products")
}

model ProductImage {
  imageId       Int      @id @default(autoincrement())
  productId     Int
  imageUrl      String
  isPrimary     Boolean  @default(false)
  hidden        Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  featureVector Json?

  product Product @relation(fields: [productId], references: [productId])

  @@index([productId], name: "productImageIndex")
  @@map("product_images")
}

model ProductVariant {
  variantId Int      @id @default(autoincrement())
  productId Int
  name      String
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  product Product @relation(fields: [productId], references: [productId])

  @@unique([productId, name, value], name: "uniqueProductVariant")
  @@index([productId, name], name: "productVariantIndex")
  @@map("product_variants")
}

// ======================
// ORDER MANAGEMENT
// ======================
model Order {
  orderId     Int         @id @default(autoincrement())
  orderType   OrderType   @default(SELLER_ORDER) // Type of order, defaulting to SELLER_ORDER
  orderStatus OrderStatus // Status of the order
  createdAt   DateTime    @default(now()) // Timestamp for when the order was created
  updatedAt   DateTime    @updatedAt // Timestamp for when the order was last updated

  cancelled       Boolean    @default(false) // Flag to indicate if the order is cancelled
  cancelledAt     DateTime? // Timestamp for when the order was cancelled
  cancelledBy     OrderUser? // Phone number of the user who cancelled the order
  cancelledReason String? // Reason for cancellation

  customerName     String // Name of the customer
  customerPhoneNo  String // Phone number of the customer
  customerAddress  String // Address of the customer
  customerZilla    String // Zilla of the customer
  customerUpazilla String // Upazilla of the customer
  customerComments String? // Comments from the customer

  shopId         Int // Foreign key to Shop table
  shopName       String // Name of the shop associated with the order
  shopLocation   String // Location of the shop associated with the order
  deliveryCharge Decimal @db.Decimal(10, 2) // Delivery charge for the order

  sellerId       String? // Foreign key to User table (seller)
  sellerName     String? // Name of the seller associated with the order
  sellerPhoneNo  String? // Phone number of the seller associated with the order
  sellerVerified Boolean? @default(false) // Flag to indicate if the seller is verified
  sellerShopName String? // Name of the seller's shop
  sellerBalance  Decimal? @default(0.0) @db.Decimal(15, 2) // Balance of the seller

  courierName String? // Name of the courier service
  trackingUrl String? // URL for tracking the order

  isDeliveryChargePaid Boolean       @default(false) // Flag to indicate if the delivery charge is paid
  deliveryChargePaidAt DateTime? // Timestamp when the delivery charge was paid
  paymentType          PaymentMethod?
  paymentVerified      Boolean       @default(false) // Flag to indicate if the payment is verified
  Payment              Payment?      @relation("OrderPayment")

  totalProductQuantity     Int     @default(0) // Total quantity of products in the order
  totalProductSellingPrice Decimal @db.Decimal(15, 2) // Total selling price of products in the order
  totalProductBasePrice    Decimal @db.Decimal(15, 2) // Total base price of products in the order
  totalCommission          Decimal @db.Decimal(15, 2) // Total commission for the order
  amountPaidByCustomer     Decimal? @db.Decimal(15, 2) // Total amount paid by the customer
  actualCommission         Decimal? @db.Decimal(15, 2) // Actual commission after deductions
  cashOnAmount             Decimal? @db.Decimal(15, 2) // Amount to be collected on delivery

  OrderProduct OrderProduct[]
}

model OrderProduct {
  orderProductId Int @id @default(autoincrement())
  orderId        Int

  productId           Int
  productName         String
  productImage        String?
  productBasePrice    Decimal @db.Decimal(15, 2) // Base price of the product
  productSellingPrice Decimal @db.Decimal(15, 2) // Selling price of the product
  productQuantity     Int     @default(1) // Quantity of the product in the order
  productVariant      String? // Variant of the product, if applicable

  totalProductBasePrice    Decimal @db.Decimal(15, 2) // Total base price for the product
  totalProductSellingPrice Decimal @db.Decimal(15, 2) // Total selling price for the product
  totalProductQuantity     Int     @default(0) // Total quantity of

  // define relationships
  order Order @relation(fields: [orderId], references: [orderId])
}

//=======================
// Withdraw MANAGEMENT
// ======================

model Withdraw {
  withdrawId      String         @id @default(cuid())
  requestedAt     DateTime       @default(now()) // Timestamp when the withdrawal was requested
  processedAt     DateTime? // Timestamp when the withdrawal was processed
  withdrawStatus  WithdrawStatus @default(PENDING) // Status of the withdrawal
 

  userId              String // Foreign key to User table
  userName            String // Name of the user associated with the withdrawal
  userPhoneNo         String // Phone number of the user associated with the withdrawal
  amount              Decimal  @db.Decimal(15, 2) // Amount requested for withdrawal
  transactionFee      Decimal? @db.Decimal(15, 2) // Transaction fee, if applicable
  actualAmount        Decimal? @db.Decimal(15, 2) // Actual amount after
  transactionId       String? // Transaction ID for the withdrawal, if applicable
  walletName          String // Name of the wallet associated with the withdrawal
  walletPhoneNo       String // Phone number associated with the wallet
  systemWalletPhoneNo String? // Phone number associated with the system wallet (if applicable)
  paymentId           String? // Foreign key to Payment table, if applicable
  remarks             String? // Optional remarks or notes about the withdrawal

  @@map("withdraws")
}

// ======================
// Payment MANAGEMENT
// ======================

model Payment {
  paymentId     String        @id @default(cuid())
  paymentDate   DateTime      @default(now()) // Date of the payment
  paymentStatus PaymentStatus @default(PENDING) // Status of the payment
  paymentType   PaymentType // Type of payment (e.g., ORDER_PAYMENT, WITHDRAWAL_PAYMENT, DUE_PAYMENT)
  processedAt   DateTime? // Timestamp when the payment was processed

  sender SenderType // Type of sender (e.g., SELLER, SYSTEM, CUSTOMER)

  userWalletName      String // Name of the wallet associated with the payment
  userWalletPhoneNo   String // Phone number associated with the wallet
  systemWalletName    String? // Name of the system wallet (if applicable)
  systemWalletPhoneNo String? // Phone number associated with the system wallet (if applicable)

  amount         Decimal  @db.Decimal(15, 2) // Amount of the payment
  transactionId  String?  @unique
  transactionFee Decimal? @db.Decimal(15, 2) // Transaction fee, if applicable
  actualAmount   Decimal? @db.Decimal(15, 2) // Actual amount after fees, if applicable

  userName    String // Name of the user associated with the payment
  userPhoneNo String // Phone number of the user associated with the payment

  remarks String? // Optional remarks or notes about the payment

  orderId Int?   @unique
  Order   Order? @relation("OrderPayment", fields: [orderId], references: [orderId])

  @@map("payments")
}

// ======================
// Transaction Management
// ======================

model Transaction {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now()) @db.Timestamp(6) // Timestamp for when the transaction was created
  userId      String // Foreign key to User table
  userName    String // Name of the transaction (e.g., "Sell Commission", "Team Commission", etc.)
  userPhoneNo String // Phone number of the user

  amount    Decimal @db.Decimal(15, 2) // Amount of the transaction (suitable for financial transactions)
  reason    String // Reason for the transaction (e.g., "Sell Commission", "Team Commission", etc.)
  reference Json? // Reference details for credit transactions (e.g., "Referred Person")

  @@map("transactions")
}
