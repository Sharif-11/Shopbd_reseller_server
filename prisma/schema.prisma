// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "rhel-openssl-1.0.x", "linux-musl"]
  // previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // extensions = [vector]
}

model Otp {
  id             String    @id @default(cuid()) // Use cuid for unique id
  phoneNo        String    @unique
  isVerified     Boolean   @default(false)
  isBlocked      Boolean   @default(false)
  totalOTP       Int       @default(0)
  otp            String // Optional
  otpCreatedAt   DateTime // Optional, timestamp when OTP was created
  otpExpiresAt   DateTime // Optional, timestamp when OTP expires
  otpBlockUntil  DateTime? // Optional, timestamp until which the OTP is blocked
  failedAttempts Int       @default(0) // Count of failed attempts
  createdAt      DateTime  @default(now()) // Timestamp for creation
  updatedAt      DateTime  @updatedAt // Timestamp for updates

  @@index([phoneNo], name: "contactIndex")
  @@map("otp") // Optional: Custom table name in the database
}

// User Management Schema

// ======================
// ENUMS
// ======================

enum UserType {
  Seller
  Admin
  SuperAdmin // Changed from Super_Admin
}

enum PermissionType {
  USER_MANAGEMENT
  PRODUCT_MANAGEMENT
  ORDER_MANAGEMENT
  WITHDRAWAL_MANAGEMENT
  PAYMENT_MANAGEMENT
  WALLET_ADDITION
  WALLET_MANAGEMENT
  ROLE_PERMISSIONS
  ALL
}

enum ActionType {
  ALL
  CREATE
  READ
  UPDATE
  DELETE
  APPROVE
  REJECT
  BLOCK
}

enum BlockActionType {
  ORDER_REQUEST
  WITHDRAW_REQUEST
  PASSWORD_RESET
  PAYMENT_REQUEST
  WALLET_ADDITION
  ALL
}

// ======================
// MODELS
// ======================

model User {
  userId                     String    @id @default(cuid())
  phoneNo                    String    @unique
  name                       String
  password                   String
  passwordSendsAt            DateTime?
  totalPasswordResetRequests Int       @default(0)

  role UserType @default(Seller)

  zilla               String?
  upazilla            String?
  address             String?
  referralCode        String?    @unique
  referredBy          User?      @relation("UserReferredBy", fields: [referredByPhone], references: [phoneNo], onDelete: NoAction, onUpdate: Cascade)
  referredByPhone     String?
  referrals           User[]     @relation("UserReferredBy")
  email               String?    @unique
  isVerified          Boolean?   @default(false)
  balance             Decimal?   @default(0.0) @db.Decimal(15, 2)
  shopName            String?
  nomineePhone        String?
  facebookProfileLink String?
  createdAt           DateTime   @default(now())
  updatedAt           DateTime   @updatedAt
  version             Int        @default(1)
  userRoles           UserRole[]
  Wallet              Wallet[]

  @@index([phoneNo], name: "userIndex")
  @@map("users")
}

model Customer {
  customerId      String   @id @default(cuid())
  customerName    String
  customerPhoneNo String   @unique
  role            String   @default("Customer") // Constant string value
  sellerId        String
  sellerCode      String
  sellerName      String
  sellerPhone     String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([customerPhoneNo], name: "customerPhoneIndex")
  @@map("customers")
}

model Role {
  roleId          String           @id @default(cuid())
  roleName        String           @unique @default("Seller")
  roleDescription String?
  isDefault       Boolean          @default(false)
  permissions     RolePermission[]
  userRoles       UserRole[]
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@map("roles")
}

model RolePermission {
  rolePermissionId String         @id @default(cuid())
  roleId           String
  permission       PermissionType
  actions          ActionType[]
  role             Role           @relation(fields: [roleId], references: [roleId])

  @@unique([roleId, permission])
  @@map("role_permissions")
}

model UserRole {
  userRoleId String @id @default(cuid())
  userId     String
  roleId     String
  user       User   @relation(fields: [userId], references: [userId])
  role       Role   @relation(fields: [roleId], references: [roleId])

  @@unique([userId, roleId])
  @@map("user_roles")
}

model Block {
  blockId     String       @id @default(cuid())
  userName    String
  userPhoneNo String
  actions     BlockAction[] // One-to-many relationship with BlockAction
  isActive    Boolean      @default(true)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@index([userPhoneNo], name: "blockUserPhoneIndex")
  @@map("blocks")
}

model BlockAction {
  actionId    String            @id @default(cuid())
  block       Block             @relation(fields: [blockId], references: [blockId])
  blockId     String
  actionType  BlockActionType
  reason      String?
  expiresAt   DateTime?
  createdAt   DateTime          @default(now())

  // Properly define the composite unique constraint
  @@unique([blockId, actionType])
  @@map("block_actions")
}
// ======================
// RELATIONSHIP DIAGRAM
// ======================

// User ↔ UserRole ↔ Role
// Role ↔ RolePermission
// User → User (self-referential for referrals)
// Block → User/Customer (via userPhoneNo)

// ======================
// WALLET MANAGEMENT
// ======================
model Wallet {
  walletId      Int        @id @default(autoincrement()) // Primary key, auto-incremented
  walletName    String // Name of the wallet
  walletPhoneNo String // Associated phone number
  walletType    WalletType @default(SELLER) // Type of wallet, defaulting to SELLER

  user   User?   @relation(fields: [userId], references: [userId])
  userId String?

  createdAt DateTime @default(now()) // Timestamp for creation
  updatedAt DateTime @updatedAt // Timestamp for updates

  @@unique([walletName, walletPhoneNo]) // Composite unique constraint
  @@map("wallets") // Optional: Custom table name in the database
}

model WalletOtp {
  id             String    @id @default(cuid()) // Use cuid for unique id
  phoneNo        String    @unique
  isVerified     Boolean   @default(false)
  isBlocked      Boolean   @default(false)
  totalOTP       Int       @default(0)
  otp            String // Optional
  otpCreatedAt   DateTime // Optional, timestamp when OTP was created
  otpExpiresAt   DateTime // Optional, timestamp when OTP expires
  otpBlockUntil  DateTime? // Optional, timestamp until which the OTP is blocked
  failedAttempts Int       @default(0) // Count of failed attempts
  createdAt      DateTime  @default(now()) // Timestamp for creation
  updatedAt      DateTime  @updatedAt // Timestamp for updates

  @@index([phoneNo], name: "walletOtpIndex") // Index for phoneNo
  @@map("wallet_otp") // Optional: Custom table name in the database
}

enum WalletType {
  SELLER
  SYSTEM
}

// ======================
// PRODUCT MANAGEMENT
// ======================

model Shop {
  shopId                Int         @id  @default(autoincrement())
  shopName              String
  shopLocation          String
  shopIcon              String? // New optional field for shop icon
  deliveryChargeInside  Decimal        @db.Decimal(10, 2)
  deliveryChargeOutside Decimal        @db.Decimal(10, 2)
  shopDescription       String?
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
  isActive              Boolean        @default(true)
  Product               Product[]
  shopCategories        ShopCategory[]

  @@map("shops")
}

// All other models remain exactly the same as in your previous schema
model Category {
  categoryId     Int            @id @default(autoincrement())
  name           String
  categoryIcon   String?
  description    String?
  parentId       Int?           // Reference to parent category
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  Product        Product[]
  shopCategories ShopCategory[]
  
  // Self-referential relationship for parent-child
  parentCategory         Category?      @relation("CategoryHierarchy", fields: [parentId], references: [categoryId])
  subCategories       Category[]     @relation("CategoryHierarchy")

  @@map("categories")
}

model ShopCategory {
  shopCategoryId Int      @id @default(autoincrement())
  shopId         Int
  categoryId     Int
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  shop     Shop     @relation(fields: [shopId], references: [shopId])
  category Category @relation(fields: [categoryId], references: [categoryId])

  @@unique([shopId, categoryId], name: "uniqueShopCategory")
  @@map("shop_categories")
}

model Product {
  productId         Int      @id @default(autoincrement())
  categoryId        Int
  shopId            Int
  name              String
  description       String
  published         Boolean  @default(false)
  videoUrl          String?
  basePrice         Decimal  @db.Decimal(15, 2)
  suggestedMaxPrice Decimal  @db.Decimal(15, 2)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  category       Category         @relation(fields: [categoryId], references: [categoryId])
  shop           Shop             @relation(fields: [shopId], references: [shopId])
  ProductImage   ProductImage[]
  ProductVariant ProductVariant[]

  @@map("products")
}

model ProductImage {
  imageId       Int      @id @default(autoincrement())
  productId     Int
  imageUrl      String
  isPrimary     Boolean  @default(false)
  hidden        Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  featureVector Json?

  product Product @relation(fields: [productId], references: [productId])

  @@index([productId], name: "productImageIndex")
  @@map("product_images")
}

model ProductVariant {
  variantId Int      @id @default(autoincrement())
  productId Int
  name      String
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  product Product @relation(fields: [productId], references: [productId])

  @@unique([productId, name, value], name: "uniqueProductVariant")
  @@index([productId, name], name: "productVariantIndex")
  @@map("product_variants")
}

// ======================
